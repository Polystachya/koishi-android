permissions:
  contents: write
  releases: write

on:
  release:
    types:
      - created
  workflow_dispatch:
    inputs:
      target_release:
        description: 'Target release tag (leave empty for latest)'
        required: false
        default: ''
        type: string
      build_purpose:
        description: 'Build purpose'
        required: true
        default: 'release'
        type: choice
        options:
          - release
          - prerelease
          - test

jobs:
  upload:
    strategy:
      matrix:
        build:
          - name: koishi-android
            copy: copy
          - name: koishi-android-with-chromium
            copy: copy-extra
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make log collector executable
        run: chmod +x .github/scripts/log-collector.sh

      - name: Collect system information
        run: |
          .github/scripts/log-collector.sh collect-system

      - name: Set up variables
        id: vars
        run: |
          echo "::group::Setting up build variables"
          
          if [[ "${{ github.event_name }}" == "release" ]]; then
            # Release created event - use event payload
            TAG="${{ github.event.release.tag_name }}"
            UPLOAD_URL="${{ github.event.release.upload_url }}"
            IS_PRERELEASE="${{ github.event.release.prerelease }}"
            echo "Triggered by release creation: $TAG"
          else
            # Manual trigger - determine target
            INPUT_TAG="${{ github.inputs.target_release }}"
            BUILD_PURPOSE="${{ github.inputs.build_purpose }}"
            
            if [[ -n "$INPUT_TAG" ]]; then
              TAG="$INPUT_TAG"
            else
              # Get latest release
              LATEST_RELEASE=$(curl \
                -sS \
                -H 'Accept: application/vnd.github.v3+json' \
                -H 'Authorization: token ${{ github.token }}' \
                https://api.github.com/repos/${{ github.repository }}/releases/latest)
              TAG=$(echo "$LATEST_RELEASE" | jq -r '.tag_name')
            fi
            
            # For manual triggers, we need to construct upload_url
            UPLOAD_URL="https://uploads.github.com/repos/${{ github.repository }}/releases"
            
            # Set prerelease flag based on input
            if [[ "$BUILD_PURPOSE" == "prerelease" ]]; then
              IS_PRERELEASE=true
            elif [[ "$BUILD_PURPOSE" == "test" ]]; then
              IS_PRERELEASE=true
            else
              IS_PRERELEASE=false
            fi
            
            echo "Manual trigger - target: $TAG, purpose: $BUILD_PURPOSE"
          fi
          
          echo "TAG=$TAG" >> $GITHUB_OUTPUT
          echo "UPLOAD_URL=$UPLOAD_URL" >> $GITHUB_OUTPUT
          echo "IS_PRERELEASE=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Validate release exists
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "::group::Validating release exists"
          
          VALIDATION_RESULT=$(./.github/scripts/log-collector.sh execute "validate-release" "
            TAG='${{ steps.vars.outputs.TAG }}'
            
            # Check if release exists
            RELEASE_INFO=\$(curl \
              -sS \
              -H 'Accept: application/vnd.github.v3+json' \
              -H 'Authorization: token ${{ github.token }}' \
              https://api.github.com/repos/${{ github.repository }}/releases/tags/\$TAG)
            
            if [[ \$(echo \"\$RELEASE_INFO\" | jq -r '.message') == \"Not Found\" ]]; then
              echo \"âŒ Release \$TAG not found. Please create the release first.\"
              exit 1
            fi
            
            UPLOAD_URL=\$(echo \"\$RELEASE_INFO\" | jq -r '.upload_url' | cut -d'{' -f1)
            echo \"UPLOAD_URL=\$UPLOAD_URL\" >> \$GITHUB_OUTPUT
            echo \"âœ… Found release: \$TAG\"
          ")
          
          EXIT_CODE=${VALIDATION_RESULT%%:*}
          LOG_FILE=${VALIDATION_RESULT##*:}
          
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "âŒ Release validation failed"
            exit 1
          fi
          
          echo "::endgroup::"

      - name: Install nix with logging
        run: |
          echo "::group::Installing Nix"
          .github/scripts/log-collector.sh execute "install-nix" "uses cachix/install-nix-action@v20"
          echo "::endgroup::"

      - name: setup cachix with logging
        uses: cachix/cachix-action@v12
        with:
          name: koishi
          authToken: ${{ secrets.CACHIX_TOKEN }}

      - name: Setup Java with logging
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '11'
          cache: gradle

      - name: Build with comprehensive logging
        run: |
          echo "::group::Building ${{ matrix.build.name }}"
          
          TAG="${{ steps.vars.outputs.TAG }}"
          BUILD_PURPOSE="${{ github.inputs.build_purpose || 'release' }}"
          
          # Adjust version code for different build types
          BASE_VERSION_CODE=$(echo "${TAG:1}" | sed 's/\.//g')
          
          case "$BUILD_PURPOSE" in
            "prerelease")
              VERSION_CODE="9${BASE_VERSION_CODE}"  # 9xxx for prerelease
              ;;
            "test")
              VERSION_CODE="8${BASE_VERSION_CODE}"  # 8xxx for test
              ;;
            *)
              VERSION_CODE="${BASE_VERSION_CODE}"   # Normal for release
              ;;
          esac
          
          BUILD_RESULT=$(./.github/scripts/log-collector.sh execute "build-${{ matrix.build.copy }}" "
            export VERSION_CODE='$VERSION_CODE'
            export VERSION_NAME='$TAG'
            export COPY='${{ matrix.build.copy }}'
            
            echo \"Building ${{ matrix.build.name }} with VERSION_CODE=\$VERSION_CODE\"
            ./build.sh
          ")
          
          EXIT_CODE=${BUILD_RESULT%%:*}
          LOG_FILE=${BUILD_RESULT##*:}
          
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "âŒ Build failed for ${{ matrix.build.name }} (exit code: $EXIT_CODE)"
            echo "ðŸ“‹ Check log file: $LOG_FILE"
            exit 1
          fi
          
          echo "âœ… Build completed for ${{ matrix.build.name }}"
          echo "::endgroup::"

      - name: Sign APK with logging
        id: sign_app
        run: |
          echo "::group::Signing ${{ matrix.build.name }}"
          
          SIGN_RESULT=$(./.github/scripts/log-collector.sh execute "sign-${{ matrix.build.copy }}" "
            echo \"Setting up signing environment for ${{ matrix.build.name }}...\"
            echo \"Key alias: koishi-android\"
            echo \"Signing key configured: ***\"
            echo \"Keystore password configured: ***\"
            echo \"Key password configured: ***\"
          ")
          
          # Note: The above logs the setup, actual signing is done by the action
          echo "::endgroup::"

      - name: Sign app APK (actual)
        uses: ilharp/sign-android-release@v1
        with:
          keyAlias: koishi-android
          signingKey: ${{ secrets.JKS }}
          keyStorePassword: ${{ secrets.JKS_PASSWORD }}
          keyPassword: ${{ secrets.JKS_PASSWORD }}

      - name: Upload to Release with logging
        if: github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && github.inputs.build_purpose != 'test')
        run: |
          echo "::group::Uploading ${{ matrix.build.name }} to Release"
          
          # Prepare filename with build purpose suffix
          BUILD_PURPOSE="${{ github.inputs.build_purpose || 'release' }}"
          TAG="${{ steps.vars.outputs.TAG }}"
          FILENAME="${{ matrix.build.name }}-${TAG}"
          
          # Add suffix for non-release builds
          if [[ "$BUILD_PURPOSE" == "prerelease" ]]; then
            FILENAME="${FILENAME}-pre"
          elif [[ "$BUILD_PURPOSE" == "test" ]]; then
            FILENAME="${FILENAME}-test"
          fi
          
          FILENAME="${FILENAME}.apk"
          ENCODED_NAME=$(printf "%s" "$FILENAME" | jq -sRr @uri)
          
          echo "Uploading: $FILENAME"
          
          UPLOAD_RESULT=$(./.github/scripts/log-collector.sh execute "upload-${{ matrix.build.copy }}" "
            UPLOAD_RESPONSE=\$(curl -s \
              -X POST \
              -H 'Accept: application/vnd.github.v3+json' \
              -H 'Content-Type: application/octet-stream' \
              -H 'Authorization: token ${{ github.token }}' \
              --data-binary @${{steps.sign_app.outputs.signedFile}} \
              \"${{ steps.vars.outputs.UPLOAD_URL }}?name=${ENCODED_NAME}\")
            
            # Check upload result
            BROWSER_URL=\$(echo \"\$UPLOAD_RESPONSE\" | jq -r '.browser_download_url')
            if [[ \"\$BROWSER_URL\" == \"\" ]] || [[ -z \"\$BROWSER_URL\" ]]; then
              echo \"âŒ Upload failed\"
              echo \"Response: \$UPLOAD_RESPONSE\"
              exit 1
            fi
            
            echo \"âœ… Uploaded successfully: \$BROWSER_URL\"
            echo \"browser_url=\$BROWSER_URL\" >> \$GITHUB_OUTPUT
          ")
          
          EXIT_CODE=${UPLOAD_RESULT%%:*}
          LOG_FILE=${UPLOAD_RESULT##*:}
          
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "âŒ Upload failed for ${{ matrix.build.name }}"
            exit 1
          fi
          
          echo "âœ… ${{ matrix.build.name }} uploaded successfully"
          echo "::endgroup::"

      - name: Upload as Artifact (for test builds)
        if: github.event_name == 'workflow_dispatch' && github.inputs.build_purpose == 'test'
        uses: actions/upload-artifact@v4
        with:
          name: test-${{ matrix.build.name }}-${{ steps.vars.outputs.TAG }}
          path: ${{steps.sign_app.outputs.signedFile}}
          retention-days: 7

      - name: Prepare logs for upload
        if: always()
        run: |
          BUILD_STATUS="${{ job.status }}"
          if [[ "$BUILD_STATUS" == "success" ]]; then
            BUILD_STATUS="SUCCESS"
          else
            BUILD_STATUS="FAILURE"
          fi
          
          .github/scripts/log-collector.sh summary "$BUILD_STATUS"
          .github/scripts/log-collector.sh upload "upload-logs-${{ matrix.build.name }}-${{ steps.vars.outputs.TAG }}"

      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.upload.outputs.artifact_name }}
          path: ${{ steps.upload.outputs.archive_path }}
          retention-days: 30
          if-no-files-found: warn

      - name: Build Summary
        run: |
          echo "## ðŸ“¦ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Variant:** ${{ matrix.build.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.vars.outputs.TAG }}" >> $GITHUB_STEP_SUMMARY
          echo "**Purpose:** ${{ github.inputs.build_purpose || 'release' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ github.event_name }}" == "release" ]] || [[ "${{ github.inputs.build_purpose }}" != "test" ]]; then
            echo "### âœ… Uploaded to Release" >> $GITHUB_STEP_SUMMARY
            echo "APK has been uploaded to the GitHub Release page." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ðŸ“¦ Available as Artifact" >> $GITHUB_STEP_SUMMARY
            echo "APK is available for download from the Actions artifacts." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Build Logs" >> $GITHUB_STEP_SUMMARY
          echo "Complete build logs are available as artifacts with all sensitive information filtered." >> $GITHUB_STEP_SUMMARY
          echo "Download the logs artifact for detailed debugging information." >> $GITHUB_STEP_SUMMARY